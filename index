<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ARCADE BLITZ â€” v9 Build (Final Tweaks)</title>
<style>
:root{
  --bg:#050010; --blue:#00E5FF; --mag:#9D00FF; --pink:#FF2BF0; --accent:#C8FF00; --yellow: #FFD700;
}
html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,Arial,sans-serif;color:#e6eef8;overflow:hidden}
.screen{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column; background: var(--bg); /* Ensure screens stack */ z-index: 10;}
.hidden{display:none; z-index: -1;} /* Hide and remove from layout */
#loading-wrap{width:460px;max-width:92vw;display:flex;flex-direction:column;gap:20px;align-items:center}
#loading-bar{width:100%;height:14px;background:#0b0b12;border-radius:8px;border:2px solid rgba(157,0,255,0.22);overflow:hidden}
#loading-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--blue),var(--mag));box-shadow:0 0 20px rgba(80,0,255,0.12) inset}
#title{font-size:46px;color:var(--blue);text-shadow:0 0 16px rgba(0,229,255,0.18),0 0 28px rgba(157,0,255,0.12);opacity:0;transition:opacity .9s}
#menu, #stats-menu, #help-menu {gap:14px; text-align:center} /* Shared style for menu cards */
#logo{font-size:56px;color:var(--mag);text-shadow:0 0 28px rgba(157,0,255,0.18);margin-bottom:8px}
.menu-row{display:flex;gap:12px;flex-wrap:wrap;justify-content:center}
.btn{background:rgba(10,5,25,0.6);border:2px solid rgba(157,0,255,0.18);padding:12px 18px;color:#eaf6ff;cursor:pointer;border-radius:10px;font-weight:700;user-select:none; transition: all 0.2s ease;}
.btn:hover{transform:translateY(-3px);box-shadow:0 8px 28px rgba(0,229,255,0.04)}
#ui{position:absolute;top:12px;left:12px;display:flex;gap:12px;align-items:center;font-size:14px;user-select:none; z-index: 2;}
#controls{position:absolute;top:12px;right:18px;display:flex;gap:14px;align-items:center; z-index: 2;}
.uic{background:rgba(6,4,14,0.5);padding:8px;border-radius:8px;border:1px solid rgba(157,0,255,0.08)}
.canvas-wrap{display:flex;align-items:center;justify-content:center;height:100%}
canvas{
  background: linear-gradient(135deg, #030417, #06020a, #030417, #2b0b5a, #030417);
  background-size: 300% 300%;
  animation: gradientBG 25s ease infinite;
  box-shadow:0 0 42px rgba(157,0,255,0.06);
  border-radius:12px
}
#message{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);font-size:15px;color:#cfeeff;text-shadow:0 0 12px rgba(0,229,255,0.06);user-select:none; z-index: 2;}
.small{font-size:12px;color:#cfe8ff;opacity:0.9}
#stats-display{text-align: left; font-size: 18px; line-height: 2; max-width: 300px; margin: 20px auto; background: rgba(10,5,25,0.6); border: 1px solid rgba(157,0,255,0.1); border-radius: 8px; padding: 20px;}
#stats-display span { color: var(--blue); font-weight: bold; } /* Highlight stats */

#help-display {
  text-align: left; 
  font-size: 16px; 
  line-height: 1.8; 
  max-width: 450px; 
  margin: 20px auto; 
  background: rgba(10,5,25,0.6); 
  border: 1px solid rgba(157,0,255,0.1); 
  border-radius: 8px; 
  padding: 20px;
  max-height: 70vh; /* Allow scrolling on small screens */
  overflow-y: auto;
}
#help-display h4 {
  color: var(--blue);
  margin-top: 15px;
  margin-bottom: 5px;
}
#help-display p {
  margin: 0;
  padding-left: 10px;
}
#help-display span {
    font-weight: bold;
}

@media(max-width:720px){#logo{font-size:40px}canvas{width:92vw;height:62vh}}
@keyframes gradientBG {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}
</style>
</head>
<body>

<!-- Loading -->
<div id="loading-screen" class="screen">
  <div id="loading-wrap">
    <div id="loading-bar"><div id="loading-fill"></div></div>
    <div id="title">ARCADE BLITZ</div>
  </div>
</div>

<!-- Menu -->
<div id="menu-screen" class="screen hidden">
  <div id="menu">
    <div id="logo">ARCADE BLITZ</div>
    <div class="menu-row">
      <button class="btn" id="btn-you">YOU</button>
      <button class="btn" id="btn-arcade">ARCADE MODE</button>
      <button class="btn" id="btn-daily">DAILY QUEST</button>
      <button class="btn" id="btn-blitz">BLITZ</button>
      <button class="btn" id="btn-help">HELP</button>
    </div>
    <div style="height:8px"></div>
    <div class="small" id="daily-quest-desc">Tip: Drag paddle (PC/Mobile) or use Arrow Keys (PC).</div>
  </div>
</div>

<!-- Stats Screen -->
<div id="stats-screen" class="screen hidden">
  <div id="stats-menu">
    <div id="logo">ALL-TIME STATS</div>
    <div id="stats-display">
      Total Playtime: <span id="stat-time">0m</span><br>
      Highest Level: <span id="stat-level">1</span><br>
      Bricks Broken: <span id="stat-bricks">0</span><br>
      Powerups Collected: <span id="stat-powerups">0</span><br>
      Perfect Hits: <span id="stat-perfects">0</span>
    </div>
    <div class="menu-row">
      <button class="btn" id="btn-stats-back">BACK TO MENU</button>
      <button class="btn" id="btn-stats-reset">RESET STATS</button>
    </div>
  </div>
</div>

<!-- Help Screen -->
<div id="help-screen" class="screen hidden">
  <div id="help-menu">
    <div id="logo">HOW TO PLAY</div>
    <div id="help-display">
      <h4>Core Goal</h4>
      <p>Clear all the bricks on the screen by hitting them with the ball. Clear all bricks to advance to the next level.</p>

      <h4>Controls</h4>
      <p>
        - <strong>Mobile:</strong> Drag the paddle with your finger.<br>
        - <strong>PC:</strong> Use Left/Right Arrow Keys, or drag with your mouse. Double-click the paddle to toggle mouse-follow mode.
      </p>

      <h4>Scoring & Lives</h4>
      <p>
        - You have 3 lives. Lose all lives and it's Game Over.<br>
        - <strong>Perfects:</strong> Hitting the ball with the very center of the paddle grants a "Perfect" and bonus points.<br>
        - <strong>Points for Lives:</strong> In Arcade Mode, if you lose your last life with 50+ Points, you will spend 50 points to continue with 1 life.
      </p>
      
      <h4>Game Modes</h4>
      <p>
        - <strong>Arcade:</strong> The main mode. See how many levels you can clear.<br>
        - <strong>Blitz:</strong> A 60-second score attack! Get the highest score possible. Lost balls respawn instantly, and cleared bricks are replaced immediately.<br>
        - <strong>Daily Quest:</strong> A unique, special challenge that changes every 24 hours for all players.
      </p>

      <h4>Powerups</h4>
      <p>
        <span style="color:#00E5FF;">Slow</span>: Briefly slows down the ball.<br>
        <span style="color:#C8FF00;">Shield</span>: Creates a barrier at the bottom for one save.<br>
        <span style="color:#FF2BF0;">Laser</span>: Destroys the lowest brick in the column above your paddle.<br>
        <span style="color:#FFD700;">Magnet</span>: Pulls all falling powerups towards your paddle.
      </p>
    </div>
    <div class="menu-row">
      <button class="btn" id="btn-help-back">BACK TO MENU</button>
    </div>
  </div>
</div>

<!-- Game -->
<div id="game-screen" class="screen hidden">
  <div id="ui">
    <div class="uic">Score: <span id="score">0</span></div>
    <div class="uic" id="lives-ui">Lives: <span id="lives">3</span></div>
    <div class="uic" id="level-ui">Level: <span id="level">1</span></div>
    <div class="uic" id="points-ui">Points: <span id="points">0</span></div>
    <div class="uic">Perfects: <span id="perfects">0</span></div>
  </div>

  <div id="controls">
    <div class="uic"><button class="btn" id="menu-btn">Menu</button></div>
    <div class="uic"><button class="btn" id="pause">Pause</button></div>
    <div class="uic"><button class="btn" id="restart">Restart</button></div>
  </div>

  <div class="canvas-wrap">
    <canvas id="game" width="920" height="560"></canvas>
  </div>
  <div id="message">Drag paddle or use Arrow Keys. Tap canvas to launch.</div>
</div>

<script>
(() => {
  // Screens
  const loadingScreen = document.getElementById('loading-screen');
  const menuScreen = document.getElementById('menu-screen');
  const gameScreen = document.getElementById('game-screen');
  const statsScreen = document.getElementById('stats-screen');
  const helpScreen = document.getElementById('help-screen');

  // Loading Bar
  const loadingFill = document.getElementById('loading-fill');
  const titleEl = document.getElementById('title');

  // Menu Buttons
  const btnArcade = document.getElementById('btn-arcade');
  const btnDaily = document.getElementById('btn-daily');
  const btnBlitz = document.getElementById('btn-blitz');
  const btnYou = document.getElementById('btn-you');
  const btnHelp = document.getElementById('btn-help');
  const dailyQuestDescEl = document.getElementById('daily-quest-desc');

  // Stats Screen Buttons & Displays
  const btnStatsBack = document.getElementById('btn-stats-back');
  const btnStatsReset = document.getElementById('btn-stats-reset');
  const statTime = document.getElementById('stat-time');
  const statLevel = document.getElementById('stat-level');
  const statBricks = document.getElementById('stat-bricks');
  const statPowerups = document.getElementById('stat-powerups');
  const statPerfects = document.getElementById('stat-perfects');

  // Help Screen Buttons
  const btnHelpBack = document.getElementById('btn-help-back');

  // Game UI
  const pauseBtn = document.getElementById('pause');
  const restartBtn = document.getElementById('restart');
  const menuBtn = document.getElementById('menu-btn');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const levelEl = document.getElementById('level');
  const pointsEl = document.getElementById('points');
  const perfectsEl = document.getElementById('perfects');
  const messageEl = document.getElementById('message');

  // UI Containers (for hiding/showing)
  const livesUI = document.getElementById('lives-ui');
  const levelUI = document.getElementById('level-ui');
  const pointsUI = document.getElementById('points-ui');


  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // Audio
  const AC = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AC ? new AC() : null;

  // Game State
  const state = {
    mode:'menu', score:0, points:0, lives:3, level:1,
    ballHeld:true, stickUsed:false, shield:false, laser:false, slowUntil:0,
    magnet:false, magnetUntil:0,
    paused:false, perfects:0, blitzMult:1,
    dailyQuestType: 0, dailyGoal: 0, dailyTimer: 0, // Daily Quest state
    blitzTimer: 0 // Blitz mode timer
  };

  // Game Objects
  const paddle = { x:(W-140)/2, y:H-64, w:140, h:18, color:'#00E5FF' };
  const ball = { x:paddle.x + paddle.w/2, y:paddle.y - 12, r:9, vx:0, vy:0, trail:[] };
  let bricks = [];
  let powerups = [];
  let floating = [];

  // Timing & Controls
  let lastTS = 0;
  let dragging=false, dragOffset=0;
  let shake = {x:0,y:0,dur:0};
  let keys = {};
  let paddleFollowsMouse = false;

  // Stats Object
  let stats = {
    totalTime: 0, // in milliseconds
    highestLevel: 1,
    bricksBroken: 0,
    powerupsCollected: 0,
    totalPerfects: 0
  };

  // Daily Quest Info
  const dailyQuestNames = [
    "Daily Quest: Clear 'The Vault'!",
    "Daily Quest: Get 10 Perfect hits!",
    "Daily Quest: Survive for 90 seconds!",
    "Daily Quest: Powerup Frenzy!"
  ];

  function getDayOfYear() {
    const now = new Date();
    const start = new Date(now.getFullYear(), 0, 0);
    const diff = now - start;
    const oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
  }

  function loadStats() {
    const savedStats = localStorage.getItem('arcadeBlitzStatsV1');
    if (savedStats) {
      try {
        const parsedStats = JSON.parse(savedStats);
        if (parsedStats && typeof parsedStats.totalTime === 'number') {
            stats = parsedStats;
        } else {
            console.warn("Parsed stats invalid, resetting.");
        }
      } catch (e) {
        console.error("Failed to parse stats, resetting.", e);
      }
    }
  }

  function saveStats() {
    if (state.level > stats.highestLevel && state.mode === 'arcade') {
      stats.highestLevel = state.level;
    }
    localStorage.setItem('arcadeBlitzStatsV1', JSON.stringify(stats));
  }

  loadStats();

  // --- Sound Effects ---
  function osc(freq, type='sine', time=0.06, vol=0.03){
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + time);
  }
  function sfxHit(){ osc(880,'sine',0.04,0.02); }
  function sfxBrick(){ osc(1200,'square',0.06,0.03); }
  function sfxPower(){ osc(480,'triangle',0.08,0.03); }
  function sfxPerfect(){ osc(1600,'sine',0.09,0.035); }
  function sfxLose(){ osc(220,'sine',0.18,0.04); }

  // --- Arcade Music ---
  let baseTempo = 180; // ms per note
  let noteIdx = 0;
  const arpeggio = [130.81, 164.81, 196.00, 164.81]; 
  let musicInterval = null;

  function playMusicNote(){
    if(!audioCtx || state.paused) return;
    osc(arpeggio[noteIdx % arpeggio.length], 'square', 0.12, 0.015);
    noteIdx++;
  }
  
  function startArcadeMusic(level){
    if(!audioCtx) return;
    stopArcadeMusic(); 
    const currentTempo = Math.max(80, baseTempo - (level - 1) * 8); 
    musicInterval = setInterval(playMusicNote, currentTempo);
  }
  
  function stopArcadeMusic(){
    if(musicInterval) clearInterval(musicInterval);
    musicInterval = null;
  }

  // --- Screen Management ---
  function runIntro(){
    loadingScreen.classList.remove('hidden');
    menuScreen.classList.add('hidden');
    gameScreen.classList.add('hidden');
    statsScreen.classList.add('hidden');
    helpScreen.classList.add('hidden');
    
    let pct = 0;
    const start = performance.now();
    const duration = 2000;
    function step(now){
      pct = Math.min(100, (now - start)/duration * 100);
      loadingFill.style.width = pct + '%';
      if(pct < 100) requestAnimationFrame(step);
      else {
        titleEl.style.opacity = 1;
        setTimeout(()=>{ loadingScreen.classList.add('hidden'); showMenu(); }, 3200);
      }
    }
    requestAnimationFrame(step);
  }

  function showMenu(){ 
    menuScreen.classList.remove('hidden'); 
    state.mode='menu';
    // Set daily quest text
    const dayOfYear = getDayOfYear();
    state.dailyQuestType = dayOfYear % 4;
    dailyQuestDescEl.textContent = dailyQuestNames[state.dailyQuestType];
  }

  function updateStatsDisplay() {
    const totalMinutes = Math.floor(stats.totalTime / 60000);
    statTime.textContent = `${totalMinutes} minutes`;
    statLevel.textContent = stats.highestLevel;
    statBricks.textContent = stats.bricksBroken;
    statPowerups.textContent = stats.powerupsCollected;
    statPerfects.textContent = stats.totalPerfects;
  }

  function showStatsScreen() {
    menuScreen.classList.add('hidden');
    statsScreen.classList.remove('hidden');
    helpScreen.classList.add('hidden');
    updateStatsDisplay();
  }

  function showHelpScreen() {
    menuScreen.classList.add('hidden');
    statsScreen.classList.add('hidden');
    helpScreen.classList.remove('hidden');
  }
  
  function startMode(mode){
    try{ if(audioCtx && audioCtx.state === 'suspended'){ audioCtx.resume(); } }catch(e){}
    startArcadeMusic(state.level);
    menuScreen.classList.add('hidden');
    statsScreen.classList.add('hidden');
    helpScreen.classList.add('hidden');
    gameScreen.classList.remove('hidden');
    state.mode = mode;

    initGame();
  }

  // --- Button Listeners ---
  btnArcade.onclick = ()=> startMode('arcade');
  btnDaily.onclick = ()=> {
    const dayOfYear = getDayOfYear();
    state.dailyQuestType = dayOfYear % 4;
    startMode('daily');
  };
  btnYou.onclick = ()=> showStatsScreen();
  btnHelp.onclick = ()=> showHelpScreen();

  btnStatsBack.onclick = ()=> {
    statsScreen.classList.add('hidden');
    showMenu();
  };

  btnHelpBack.onclick = ()=> {
    helpScreen.classList.add('hidden');
    showMenu();
  };

  btnStatsReset.onclick = ()=> {
    if (btnStatsReset.textContent === 'RESET STATS') {
        btnStatsReset.textContent = 'CLICK TO CONFIRM RESET';
        btnStatsReset.style.background = 'var(--pink)';
        btnStatsReset.style.color = '#000';
        setTimeout(() => {
            btnStatsReset.textContent = 'RESET STATS';
            btnStatsReset.style.background = '';
            btnStatsReset.style.color = '';
        }, 3000);
      } else {
        stats = { totalTime: 0, highestLevel: 1, bricksBroken: 0, powerupsCollected: 0, totalPerfects: 0 };
        saveStats();
        updateStatsDisplay();
        btnStatsReset.textContent = 'STATS RESET!';
        btnStatsReset.style.background = 'var(--accent)';
        btnStatsReset.style.color = '#000';
        setTimeout(() => {
            btnStatsReset.textContent = 'RESET STATS';
            btnStatsReset.style.background = '';
            btnStatsReset.style.color = '';
        }, 2000);
      }
  };

  // *** NEW BLITZ BUTTON ***
  btnBlitz.addEventListener('click', ()=>{
    startMode('blitz');
  });

  pauseBtn.onclick = ()=> { state.paused = !state.paused; pauseBtn.textContent = state.paused ? 'Resume' : 'Pause'; }
  restartBtn.onclick = ()=> initGame();
  
  menuBtn.onclick = ()=> { 
    stopArcadeMusic(); 
    state.mode = 'menu'; 
    gameScreen.classList.add('hidden'); 
    showMenu(); 
    state.paused = false;
    pauseBtn.textContent = 'Pause'; 
    saveStats();
  }

  // --- Game Init ---
  function initGame(){
    state.score = 0; state.points = 0; state.lives = 3; state.level = 1;
    state.ballHeld = true; state.stickUsed = false; state.shield=false; state.laser=false; state.slowUntil=0; state.perfects=0;
    state.magnet=false; state.magnetUntil=0;
    state.dailyGoal = 0; state.dailyTimer = 0;
    state.blitzTimer = 0;
    
    paddle.w = 140; paddle.x = (W - paddle.w)/2; paddle.y = H - 64;
    ball.trail = []; powerups = []; floating = [];
    keys = {}; paddleFollowsMouse = false;

    if (state.mode === 'daily') {
        state.blitzMult = 1.0;
        initDailyQuest(state.dailyQuestType);
    } else if (state.mode === 'blitz') {
        state.blitzTimer = 60 * 1000; // 60 seconds
        state.blitzMult = 1.4; // Fixed fast speed
        state.lives = 99; // "Infinite" lives
        showMessage("Blitz Mode: Get the highest score in 60s!");
        spawnLevel(1);
    } else { // Arcade mode
        state.blitzMult = 1.0;
        spawnLevel(state.level);
    }
    
    updateHUD();
  }

  function initDailyQuest(questType) {
    switch(questType) {
      case 0: // "The Vault"
        showMessage("Daily Quest: Clear 'The Vault'!");
        spawnVaultLevel();
        break;
      case 1: // "Skill Shot"
        showMessage("Daily Quest: Get 10 Perfect hits!");
        state.dailyGoal = 10;
        spawnLevel(1);
        break;
      case 2: // "Survival"
        showMessage("Daily Quest: Survive for 90 seconds!");
        state.lives = 1;
        state.dailyTimer = 90 * 1000; // 90 seconds
        state.blitzMult = 1.3; // Faster ball
        spawnLevel(1);
        break;
      case 3: // "Powerup Frenzy"
        showMessage("Daily Quest: Powerup Frenzy!");
        spawnLevel(1);
        break;
    }
  }

  function spawnLevel(level){
    bricks = [];
    const cols = 9, rows = 4;
    const margin = 48;
    const bw = (W - margin*2)/cols; const bh = 22;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = margin + c*bw + 4;
        const y = 60 + r*(bh + 8);
        const hp = 1 + Math.floor(level/4);
        bricks.push({x,y,w:bw-8,h:bh,hp,base:hp});
      }
    }
    ball.vx = 0; ball.vy = 0; state.ballHeld = true; state.stickUsed=false;
    ball.x = paddle.x + paddle.w/2; ball.y = paddle.y - 12;
    if (state.mode === 'arcade') {
        startArcadeMusic(level);
    }
  }

  function spawnVaultLevel() {
    bricks = [];
    const cols = 5, rows = 3;
    const margin = W/2 - (cols * 80) / 2; // Center the vault
    const bw = 80 - 8; const bh = 25;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = margin + c*(bw + 8) + 4;
        const y = 80 + r*(bh + 8);
        bricks.push({x,y,w:bw,h:bh,hp:5,base:5}); // All bricks have 5 HP
      }
    }
    ball.vx = 0; ball.vy = 0; state.ballHeld = true; state.stickUsed=false;
    ball.x = paddle.x + paddle.w/2; ball.y = paddle.y - 12;
  }

  function updateHUD(){
    scoreEl.textContent = state.score;
    perfectsEl.textContent = state.perfects;

    if (state.mode === 'blitz') {
        levelUI.textContent = `Time: ${Math.ceil(state.blitzTimer / 1000)}`;
        livesUI.style.display = 'none';
        pointsUI.style.display = 'none';
    } else {
        levelUI.textContent = `Level: ${(state.mode === 'daily') ? 'Daily' : state.level}`;
        livesEl.textContent = state.lives;
        pointsEl.textContent = state.points;
        livesUI.style.display = 'flex'; // 'flex' because they are in a flex container
        pointsUI.style.display = 'flex';
    }
  }

  // --- Controls ---
  function getCanvasPos(e){
    const rect = canvas.getBoundingClientRect();
    if(e.touches) return {x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top};
    return {x: e.clientX - rect.left, y: e.clientY - rect.top};
  }

  canvas.addEventListener('dblclick', (e) => {
    if (e.pointerType !== 'mouse') return;
    const p = getCanvasPos(e);
    if(p.x >= paddle.x && p.x <= paddle.x + paddle.w && p.y >= paddle.y && p.y <= paddle.y + paddle.h + 40){
      paddleFollowsMouse = !paddleFollowsMouse;
      dragging = false;
    }
  });

  window.addEventListener('keydown', (e) => { 
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') e.preventDefault();
    keys[e.key] = true; 
  });
  window.addEventListener('keyup', (e) => { keys[e.key] = false; });

  canvas.addEventListener('pointerdown', (ev)=>{
    if (paddleFollowsMouse) {
      paddleFollowsMouse = false;
      return;
    }
    if(audioCtx && audioCtx.state === 'suspended'){ audioCtx.resume(); }
    const p = getCanvasPos(ev);
    if(p.x >= paddle.x && p.x <= paddle.x + paddle.w && p.y >= paddle.y && p.y <= paddle.y + paddle.h + 40){
      dragging = true;
      // *** TWEAK 1: Immediate 1:1 centering for touch ***
      if (ev.pointerType === 'touch') {
        let nx = p.x - paddle.w / 2;
        paddle.x = Math.max(0, Math.min(W - paddle.w, nx));
        if(state.ballHeld){ ball.x = paddle.x + paddle.w/2; ball.y = paddle.y - 12; }
      } else {
        // Original mouse drag logic
        dragOffset = p.x - dragOffset;
      }
    } else {
      if(state.ballHeld) launchBall();
    }
  });
  
  window.addEventListener('pointermove', (ev)=>{
    const p = getCanvasPos(ev);
    let nx;
    if (paddleFollowsMouse) {
      nx = p.x - paddle.w / 2;
    } else if (dragging) {
      if (ev.pointerType === 'touch') {
        ev.preventDefault();
        nx = p.x - paddle.w / 2; // 1:1 centering
      } else {
        nx = p.x - dragOffset; // Mouse drag
      }
    } else {
      return;
    }
    nx = Math.max(0, Math.min(W - paddle.w, nx));
    paddle.x = nx;
    if(state.ballHeld){ ball.x = paddle.x + paddle.w/2; ball.y = paddle.y - 12; }
  }, { passive: false });

  window.addEventListener('pointerup', ()=>{ 
    dragging = false; 
  });

  // --- Game Logic ---

  function launchBall(){
    if(!state.ballHeld) return;
    state.ballHeld = false;
    const base = 5 + (state.level - 1) * 0.6;
    const vx = (Math.random()*1.2 - 0.6) * base * 0.6;
    ball.vx = vx; ball.vy = -base;
    if(audioCtx) sfxHit();
  }

  function tryStick(){
    if(state.ballHeld || state.stickUsed) { showMessage('Stick not available'); return; }
    if(ball.y + ball.r > paddle.y - 12 && ball.y < paddle.y + paddle.h + 8){
      state.ballHeld = true; state.stickUsed = true; 
      ball.x = paddle.x + paddle.w/2;
      ball.y = paddle.y - 12;
      sfxPower(); showMessage('Stick used: re-aim and launch');
    } else showMessage('Stick usable when ball is near paddle');
  }

  function spawnPower(x,y){
    const kinds = ['shield','laser','slow', 'magnet'];
    const kind = kinds[Math.floor(Math.random()*kinds.length)];
    powerups.push({x,y,vy:1.4,kind,r:10});
  }

  function applyPower(p){
    stats.powerupsCollected += 1;
    if(p.kind==='shield'){ state.shield = true; showMessage('Shield active'); sfxPower(); }
    if(p.kind==='laser'){ state.laser = true; showMessage('Laser active'); sfxPower(); setTimeout(()=>{ state.laser=false; showMessage('Laser ended'); },7000); }
    if(p.kind==='slow'){ state.slowUntil = performance.now() + 6500; showMessage('Slow mode'); sfxPower(); }
    if(p.kind==='magnet'){ state.magnet = true; state.magnetUntil = performance.now() + 8000; showMessage('Magnet active!'); sfxPower(); }
  }

  function circleRectColl(cx,cy,cr,rx,ry,rw,rh){
    const nearestX = Math.max(rx, Math.min(cx, rx+rw));
    const nearestY = Math.max(ry, Math.min(cy, ry+rh));
    const dx = nearestX - cx; const dy = nearestY - cy;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function checkPerfect(hitX){
    const center = paddle.x + paddle.w/2;
    const off = Math.abs(hitX - center);
    const tol = paddle.w * 0.12;
    if(off <= tol){
      state.score += 6; state.perfects += 1;
      stats.totalPerfects += 1;
      sfxPerfect(); showFloating('Perfect', hitX, paddle.y - 36);
    }
  }

  function doShake(strength=8,duration=220){
    shake.dur = duration; shake.x = (Math.random()*2-1)*strength; shake.y = (Math.random()*2-1)*strength;
  }

  function showFloating(txt,x,y,ttl=900){ floating.push({txt,x,y,t:performance.now(),ttl}); }

  function showMessage(t){
    messageEl.textContent = t;
    const isSpecialMode = (state.mode === 'daily' && state.dailyQuestType === 2) || state.mode === 'blitz';
    if (!isSpecialMode) {
        setTimeout(()=>{ if(messageEl.textContent===t) messageEl.textContent = 'Drag paddle or use Arrow Keys. Tap canvas to launch.'; },1600);
    }
  }

  function endGame(dailyQuestWin = false){
    if (state.mode === 'blitz') {
        showFloating(`Time's Up! Score: ${state.score}`, W/2, H/2 - 30);
    } else if (state.mode === 'daily') {
        if (dailyQuestWin) {
            showFloating('Quest Complete!', W/2, H/2 - 30);
        } else {
            showFloating('Quest Failed', W/2, H/2 - 30);
            sfxLose();
        }
    } else {
        showFloating('Game Over', W/2, H/2 - 30);
        sfxLose();
    }
    
    stopArcadeMusic();
    saveStats();
    
    // *** TWEAK 2: Longer delay for Blitz mode ***
    let endScreenDelay = (state.mode === 'blitz') ? 3000 : 1200;
    setTimeout(()=>{ gameScreen.classList.add('hidden'); showMenu(); }, endScreenDelay);
  }

  function checkDailyQuestProgress(dt) {
    if (state.mode !== 'daily') return;
    if (state.dailyQuestType === 2) { // Survival
      if (state.dailyTimer > 0) {
        state.dailyTimer -= dt * (1000/60);
        showMessage(`Survive: ${Math.ceil(state.dailyTimer / 1000)}s`);
        if (state.dailyTimer <= 0) {
          endGame(true); // Quest Complete
        }
      }
    }
  }

  function checkBlitzTimer(dt) {
      if (state.mode !== 'blitz') return;
      if (state.blitzTimer > 0) {
          state.blitzTimer -= dt * (1000/60);
          updateHUD(); // Update timer display
          if (state.blitzTimer <= 0) {
              endGame(); // Time's up
          }
      }
  }

  // --- Main Update Loop ---
  function update(dt){
    if(state.paused) return;

    checkDailyQuestProgress(dt); // Handle daily quest timers
    checkBlitzTimer(dt); // Handle blitz timer

    if (state.magnet && performance.now() > state.magnetUntil) { state.magnet = false; showMessage('Magnet ended'); }

    if (!dragging && !paddleFollowsMouse) {
      const paddleSpeed = 8 * dt;
      let moved = false;
      if (keys['ArrowLeft']) { paddle.x -= paddleSpeed; moved = true; }
      if (keys['ArrowRight']) { paddle.x += paddleSpeed; moved = true; }
      if (moved) {
        paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
        if (state.ballHeld) { ball.x = paddle.x + paddle.w/2; ball.y = paddle.y - 12; }
      }
    }
    
    if(state.ballHeld){
      // Ball position updated by paddle movement
    } else {
      let sMult = state.blitzMult; // Use the mode's speed
      if(state.slowUntil && performance.now() < state.slowUntil) sMult *= 0.72;
      ball.x += ball.vx * dt * sMult;
      ball.y += ball.vy * dt * sMult;
      ball.trail.unshift({x:ball.x,y:ball.y,t:performance.now()});
      if(ball.trail.length > 30) ball.trail.pop();

      if(ball.x - ball.r < 0){ ball.x = ball.r; ball.vx = Math.abs(ball.vx); sfxHit(); }
      else if(ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx = -Math.abs(ball.vx); sfxHit(); }
      if(ball.y - ball.r < 0){ ball.y = ball.r; ball.vy = Math.abs(ball.vy); sfxHit(); }
      
      if(ball.vy > 0 && circleRectColl(ball.x,ball.y,ball.r, paddle.x, paddle.y, paddle.w, paddle.h)){
        const rel = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
        const angle = rel * (Math.PI * 0.48);
        const speed = Math.max(4, Math.hypot(ball.vx,ball.vy));
        ball.vx = Math.sin(angle) * speed;
        ball.vy = -Math.cos(angle) * speed;
        checkPerfect(ball.x);
        sfxHit();
      }
      
      if(ball.y - ball.r > H){
        // *** BLITZ MODE BALL LOSS ***
        if (state.mode === 'blitz') {
            state.ballHeld = true;
            ball.x = paddle.x + paddle.w/2;
            ball.y = paddle.y - 12;
            sfxHit(); // Softer sound than sfxLose
        } else if(state.shield){
          state.shield = false; showMessage('Shield used'); sfxPower();
          state.ballHeld = true; ball.vx=0; ball.vy=0;
          ball.x = paddle.x + paddle.w/2;
          ball.y = paddle.y - 12;
        } else {
          state.lives -=1; 
          
          if(state.lives <= 0){
            if(state.mode === 'arcade' && state.points >= 50){
              state.points = Math.floor(state.points/2);
              state.lives = 1; 
              state.ballHeld = true;
              ball.x = paddle.x + paddle.w/2;
              ball.y = paddle.y - 12;
              showMessage('Spent points to continue');
            } else {
              endGame(false); return; // Pass false for daily quest fail
            }
          } else {
            sfxLose();
            state.ballHeld = true; ball.vx=0; ball.vy=0;
            ball.x = paddle.x + paddle.w/2;
            ball.y = paddle.y - 12;
            showMessage('Life lost');
          }
        }
        updateHUD();
      }
    }

    // --- Brick Collision ---
    for(let i=0;i<bricks.length;i++){
      const b = bricks[i];
      if(b.hp <= 0) continue;
      if(circleRectColl(ball.x,ball.y,ball.r,b.x,b.y,b.w,b.h)){
        ball.vy = -ball.vy;
        ball.y += ball.vy > 0 ? 3 : -3;
        b.hp -= 1;
        if(b.hp <= 0){
          state.score += 10; 
          state.points += (state.mode === 'arcade' ? 6 : 0); // Only arcade gives points
          stats.bricksBroken += 1;
          
          if (state.mode === 'daily' && state.dailyQuestType === 3) { // Powerup Frenzy
            spawnPower(b.x + b.w/2, b.y + b.h/2);
          } else if (Math.random() < 0.18) {
            spawnPower(b.x + b.w/2, b.y + b.h/2);
          }
          
          sfxBrick();
          doShake(10,260);
        } else {
          state.score += 4; sfxHit();
        }
        updateHUD();
        break;
      }
    }

    // --- Powerup Logic ---
    for(let i = powerups.length -1; i>=0; i--){
      const p = powerups[i];
      
      if (state.magnet && p.y > 0) {
          const paddleCenter = paddle.x + paddle.w / 2;
          const dx = paddleCenter - p.x;
          if (Math.abs(dx) > 2) { 
              p.x += (dx > 0 ? 1 : -1) * 2.0 * dt;
          }
          p.y += p.vy * 0.4 * dt;
      }

      p.y += p.vy * dt;
      
      if(p.y > paddle.y && p.x > paddle.x && p.x < paddle.x + paddle.w){
        applyPower(p); powerups.splice(i,1); updateHUD(); break;
      } else if(p.y > H + 40) powerups.splice(i,1);
    }

    // --- Laser Logic (Tweaked) ---
    if(state.laser && Math.random() < 0.08){
      const px = paddle.x + paddle.w/2;
      let targetBrick = null;
      const bricksInColumn = bricks.filter(b => b.hp > 0 && px > b.x && px < b.x + b.w);
      
      if (bricksInColumn.length > 0) {
        targetBrick = bricksInColumn.reduce((lowest, current) => (current.y > lowest.y) ? current : lowest);
      }

      if (targetBrick) {
        targetBrick.hp = 0; 
        state.score += 10; 
        stats.bricksBroken += 1;
        sfxBrick();
        updateHUD();
      }
    }

    // --- Level Cleared ---
    if(bricks.every(b=>b.hp <= 0)){
      if (state.mode === 'blitz') {
          spawnLevel(1); // Instantly respawn bricks
      } else if (state.mode === 'daily') {
        // Daily Quest win conditions
        if (state.dailyQuestType === 1) { // Skill Shot
          if (state.perfects >= state.dailyGoal) {
            endGame(true); // Win
          } else {
            endGame(false); // Fail
          }
        } else if (state.dailyQuestType === 0 || state.dailyQuestType === 3) { // Vault or Frenzy
          endGame(true); // Win by clearing
        }
        // Survival (case 2) is handled by timer
      } else {
        // Arcade mode
        state.level += 1; 
        if (state.level > stats.highestLevel) stats.highestLevel = state.level;
        state.points += 30; 
        showMessage('Level cleared!');
        spawnLevel(state.level); 
        updateHUD();
      }
    }

    // --- Floating Text ---
    for(let i=floating.length-1;i>=0;i--){
      if(performance.now() - floating[i].t > floating[i].ttl) floating.splice(i,1);
    }
  }

  // --- Main Render Loop ---
  function render(){
    let sx = 0, sy = 0;
    if(shake.dur > 0){
      sx = (Math.random()*2-1) * 6; sy = (Math.random()*2-1) * 6;
      shake.dur -= 16;
    }
    ctx.setTransform(1,0,0,1,sx,sy);
    ctx.clearRect(0,0,W,H);

    ctx.save(); ctx.globalAlpha = 0.03; ctx.fillStyle = '#0c1020';
    for(let gx=0; gx<W; gx+=24) ctx.fillRect(gx,0,1,H);
    for(let gy=0; gy<H; gy+=24) ctx.fillRect(0,gy,W,1);
    ctx.restore();

    for(const b of bricks){
      if(b.hp <= 0) continue;
      ctx.save();
      // Make high-HP bricks brighter
      const hpAlpha = 0.6 + (b.hp / b.base) * 0.4;
      ctx.fillStyle = `rgba(43, 11, 90, ${hpAlpha})`;
      ctx.shadowColor = '#9D00FF';
      ctx.shadowBlur = 14;
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.restore();
      ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.strokeRect(b.x,b.y,b.w,b.h);
    }

    // --- Powerup Rendering ---
    for(const p of powerups){
      ctx.save();
      const col = p.kind === 'shield' ? '#C8FF00' : 
                  (p.kind==='laser' ? '#FF2BF0' : 
                  (p.kind==='magnet' ? '#FFD700' : '#00E5FF'));
      ctx.fillStyle = col; 
      ctx.globalAlpha = 0.95;
      ctx.beginPath(); ctx.arc(p.x,p.y,10,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    ctx.save();
    ctx.shadowColor = paddle.color; ctx.shadowBlur = 20;
    ctx.fillStyle = paddle.color; ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
    ctx.restore();
    ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.fillRect(paddle.x,paddle.y,paddle.w,paddle.h);

    if (state.magnet) {
        ctx.save();
        const magnetPulse = Math.abs(Math.sin(performance.now() / 200)) * 0.3 + 0.7;
        ctx.globalAlpha = magnetPulse * 0.5;
        ctx.fillStyle = '#FFD700';
        ctx.shadowColor = '#FFD700';
        ctx.shadowBlur = 25;
        ctx.fillRect(paddle.x - 10, paddle.y + 4, paddle.w + 20, paddle.h - 8);
        ctx.restore();
    }

    for(let i=ball.trail.length-1;i>=0;i--){
      const t = ball.trail[i];
      const age = (performance.now() - t.t)/700;
      if(age > 1) continue;
      ctx.save();
      ctx.globalAlpha = Math.max(0, 0.6*(1-age));
      ctx.fillStyle = (i%2===0) ? 'rgba(255,43,240,0.9)' : 'rgba(0,229,255,0.9)';
      ctx.beginPath(); ctx.arc(t.x, t.y, ball.r * (0.9 * (1-age) + 0.2), 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    ctx.save(); ctx.shadowColor = '#FF2BF0'; ctx.shadowBlur = 18;
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.save(); ctx.font='16px Arial'; ctx.textAlign='center'; ctx.fillStyle='#cfe8ff';
    for(const f of floating){
      const alpha = 1 - (performance.now() - f.t)/f.ttl;
      ctx.globalAlpha = Math.max(0, alpha);
      ctx.fillText(f.txt, f.x, f.y - ((performance.now()-f.t)/60));
    }
    ctx.restore();

    ctx.setTransform(1,0,0,1,0,0);
  }

  // --- Main Loop ---
  function loop(ts){
    if(!lastTS) lastTS = ts;
    const dt = Math.min(2, (ts - lastTS) / (1000/60));
    if(state.mode !== 'menu' && !state.paused) {
      if(stats.totalTime === undefined) stats.totalTime = 0;
      stats.totalTime += dt * (1000/60);
      update(dt);
    }
    if(state.mode !== 'menu') render();
    lastTS = ts;
    requestAnimationFrame(loop);
  }

  // --- Input Handlers ---
  let lastTap = 0;
  canvas.addEventListener('pointerdown', (e)=>{
    const now = performance.now();
    if(now - lastTap < 300){
      const p = getPointer(e);
      if(p.x >= paddle.x && p.x <= paddle.x + paddle.w) tryStick();
    }
    lastTap = now;
  });

  function getPointer(e){
    const r = canvas.getBoundingClientRect();
    if(e.touches) return {x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top};
    return {x: e.clientX - r.left, y: e.clientY - r.top};
  }

  document.documentElement.addEventListener('pointerdown', function unlockAudio(){
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    if(audioCtx && !musicInterval){ startArcadeMusic(state.level); } 
    document.documentElement.removeEventListener('pointerdown', unlockAudio);
  }, {once:true});

  // Start the app
  runIntro();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>